<style type="text/css">
/*提示：如果你看到了这行文字，那说明您的预览器不支持内嵌 CSS 代码，请使用 VSCode 阅读本 Markdown 文件*/

body{font-size:15px;color:#333;background:#fff;font-family:Helvetica, Arial, "PingFang SC", "Microsoft YaHei", "WenQuanYi Micro Hei", "tohoma,sans-serif";margin:0;padding:10%}h1{font-size:2.2em;font-weight:700;line-height:1.1;padding-top:16px;margin-bottom:4px}h2, h3, h4, h5, h6{line-height:1.5em;margin-top:2.2em;margin-bottom:4px}h2{color:#ffffff !important;background-color:#ff9b98;border-left:12px solid #FF7E79;padding :1px 1px 1px 20px}h3{font-weight:700;font-size:1.2em;line-height:1.4;margin:10px 0 5px;padding-top:10px}h4{font-weight:700;text-transform:uppercase;font-size:1.1em;line-height:1.4;margin:10px 0 5px;padding-top:10px}h5, h6{font-size:.9em}h5{font-weight:bold;text-transform:uppercase}h6{font-weight:normal;color:#AAA}img{width:100%;border-radius:5px;display:block;margin-bottom:15px;height:auto}dl, ol, ul{margin-top:12px;margin-bottom:20px;padding-left:5%;line-height:1.8}p{margin:0 0 20px;padding:0;line-height:1.8}a{color:#f22f27;text-decoration:none}a:hover{color:#f55852;text-decoration:underline}a:focus{outline-offset:-2px}blockquote{font-size:1em;font-style:normal;padding:30px 38px;margin:0 0 15px;position:relative;line-height:1.8;text-indent:0;border:none;color:#888}blockquote:before{content:"“";left:12px;top:0;color:#E0E0E0;font-size:4em;font-family:Arial, serif;line-height:1em;font-weight:700;position:absolute}blockquote:after{content:"”";right:12px;bottom:-26px;color:#E0E0E0;font-size:4em;font-family:Arial, serif;line-height:1em;font-weight:700;position:absolute;bottom:-31px}strong, dfn{font-weight:700}em, dfn{font-style:italic;font-weight:400}del{text-decoration:line-through}pre{margin:0 0 10px;font-size:13px;line-height:1.42857;word-break:break-all;word-wrap:break-word;border-radius:4px;white-space:pre-wrap;display:block;background:#f8f8f8;padding:10px 20px;border:none;margin-bottom:25px;color:#666;font-family:Courier, sans-serif}code{color:#c7254e;background-color:#f9f2f4;border-radius:4px;font-family:Menlo, Monaco, Consolas, "Courier New", monospace;padding:2px 4px;font-size:90%}p>code{color:#c7264e;background-color:#f9f2f4;font-size:.95em;border-radius:3px;-moz-border-radius:3px;-webkit-border-radius:3px}figure{margin:1em 0}figcaption{font-size:0.75em;padding:0.5em 2em;margin-bottom:2em}figure img{margin-bottom:0px}hr{border:0;height:1px;background:#333;background-image:linear-gradient(to right, #ccc, #333, #ccc)}ol p, ul p{margin-bottom:0px}li{margin-bottom:0.75em;margin-top:0.75em}ol#footnotes{font-size:0.95em;padding-top:1em;margin-top:1em;margin-left:0;border-top:1px solid #eaeaea;counter-reset:footer-counter;list-style:none;color:#555;padding-left:5%;margin:20px 0}ol#footnotes li{margin-bottom:10px;margin-left:16px;font-weight:400;line-height:2;list-style-type:none}ol#footnotes li:before{content:counter(footer-counter) ". ";counter-increment:footer-counter;font-weight:800;font-size:.95em}@keyframes highfade{0%{background-color:none}20%{background-color:yellow}100%{background-color:none}}@-webkit-keyframes highfade{0%{background-color:none}20%{background-color:yellow}100%{background-color:none}}a:target, ol#footnotes li:target, sup a:target{animation-name:highfade;animation-duration:2s;animation-iteration-count:1;animation-timing-function:ease-in-out;-webkit-animation-name:highfade;-webkit-animation-duration:2s;-webkit-animation-iteration-count:1;-webkit-animation-timing-function:ease-in-out}a:target{border:0;outline:0}animation-iteration-count:1;-webkit-animation-timing-function:ease-in-out}a:target{border:0;outline:0}tion-iteration-count:1;-webkit-animation-timing-function:ease-in-out}a:target{border:0;outline:0}
table{
  background-color: #F7F7F7;
  margin:15px auto;
  border-collapse: collapse, white;
  empty-cells:show;
  
}
table th {
  font-weight: bold;
  text-align: center !important;
  background: #FF9B98;
  border : 2px solid #EFF3F5;
  color: white;
}
</style>
<div align="center">
<h1><font  color="#ff7e79"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-bookmark-check-fill" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M2 15.5V2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v13.5a.5.5 0 0 1-.74.439L8 13.069l-5.26 2.87A.5.5 0 0 1 2 15.5zm8.854-9.646a.5.5 0 0 0-.708-.708L7.5 7.793 6.354 6.646a.5.5 0 1 0-.708.708l1.5 1.5a.5.5 0 0 0 .708 0l3-3z"/>
</svg>
每天一个技术点</font>
</h1>
</div>

<HR>

<h3>
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
  <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3Zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
</svg>
本文作者：Margoo
<br>
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-calendar2-event-fill" viewBox="0 0 16 16">
  <path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zm9.954 3H2.545c-.3 0-.545.224-.545.5v1c0 .276.244.5.545.5h10.91c.3 0 .545-.224.545-.5v-1c0-.276-.244-.5-.546-.5zM11.5 7a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-1z"/>
</svg>
发布时间：2023/7/13

<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-book-fill" viewBox="0 0 16 16">
  <path d="M8 1.783C7.015.936 5.587.81 4.287.94c-1.514.153-3.042.672-3.994 1.105A.5.5 0 0 0 0 2.5v11a.5.5 0 0 0 .707.455c.882-.4 2.303-.881 3.68-1.02 1.409-.142 2.59.087 3.223.877a.5.5 0 0 0 .78 0c.633-.79 1.814-1.019 3.222-.877 1.378.139 2.8.62 3.681 1.02A.5.5 0 0 0 16 13.5v-11a.5.5 0 0 0-.293-.455c-.952-.433-2.48-.952-3.994-1.105C10.413.809 8.985.936 8 1.783z"/>
</svg>
内容概要：本文将会介绍 C++ 中的仿函数与偏函数（Partial Function Application）

</h3>


## 1. 仿函数与 lambda
### 1.1 什么是仿函数
如果一个类重载了函数调用操作符，则这个类为仿函数类（Functor），其实例称为函数（functors）又称仿函数对象（Function Object）。
### 1.2 仿函数优点
比起普通的函数，仿函数可以保存状态，且函数对象可以作为形参传递（或许会有人觉得函数可以通过 lambda 传递，其实 lambda 也是用仿函数实现的）。
### 1.3 仿函数实例
举个例子，现在需要实现一个累加函数，这个函数支持设置步长，也支持设置起始值和终止值，返回值为 bool，这个时候就可以用仿函数去解决了，这个累加器可以像这样写：
```cpp
template<class Type>
class MyRange
{
public:
	MyRange(const Type& Start, const Type& End, const Type& Step)
	{
		this->LocalVar	= Start;
		this->End		= End;
		this->Step		= Step;
	}

public:
	bool operator()()
	{
		bool Result = (LocalVar < End);
		LocalVar += Step;

		return Result;
	}
	const Type operator*() const
	{
		return LocalVar;
	}

private:
	Type LocalVar;
	Type End;
	Type Step;
};
```
最后只需要这么使用：
```cpp
int main()
{
	MyRange<int> Range(0, 10, 2);
	while (Range())
	{
		printf("%d ", *Range);
	}

	return 0;
}
```
最终输出结果为：```2 4 6 8 10```。

仿函数是 STL 中的一个重要内容，STL 中有一个函数 std::for_each，便就支持传入一个仿函数对一个迭代器进行操作。

### 1.3 lambda
lambda 其实就相当于是一个简化的函数定义，其基本结构如下：
```cpp
[capture](parameter) -> type {
  code;
}
```
其中，parameter 就是函数列表，type 就是 lambda 函数的返回类型，```-> type``` 是可以被忽略的（默认为 void），capture 为捕获列表，其中分为按值捕获（capture by value）、按引用捕获（capture by reference）、隐式捕获（implicit captures），其中的值捕获和引用捕获可以被理解为我在 2023.7.13 中写的文章“深拷贝浅拷贝”中的值语义与引用语义。

下面是一个按值捕获和按引用捕获的实例：
```cpp
int a = 0;
auto Fn1 = [a]() -> int {
  // a = 4; <- 并不能这么写，因为 a 是按值捕获，并不能修改
  return a * 2;
};
Fn1();
auto Fn2 = [&a]() -> void {
  a = 4;
};
Fn2(); // 这段代码执行后 a = 4;
```
但是值得一提的是，按引用捕获存在一定的风险，因为这个引用不一定在 lambda 执行的时候依然有效，但是对于不可复制对象只能使用引用捕获。

第三种隐式捕获如下表所示：

|捕获列表参数|意义|
|:--:|:--:|
|[]|不捕获任何变量|
|[&]|引用捕获外部作用域中的所有变量|
|[=]|按值捕获外部作用域中的所有变量|
|[=, &object1, &object2]|按值捕获外部作用域中除了 object1、object2 以外的所有变量（object1、object2 引用捕获）|
|[&, =object1, =object2]|引用捕获外部作用域中除了 object1、object2 以外的所有变量（object1、object2 按值捕获）|

### 1.4 仿函数和 lambda
在 C++ 中，我们可以这么去使用 lambda：
```cpp
auto MyFunctor = []() -> void { printf("Hello World!"); };
MyFunctor();
```
这将会输出一个 Hello World 到控制台中，上文中提到，lambda 实际上就是用仿函数实现的，我们可以通过 cppinsights 这个网站（[https://cppinsights.io/](https://cppinsights.io/)）来查看代码被编译器处理后的样子，例如上面的那个代码片段，被处理后就会是这样的：
```cpp
class __lambda_5_23
{
  public: 
  inline /*constexpr */ void operator()() const
  {
    printf("Hello World!");
  }
  
  using retType_5_23 = auto (*)() -> void;
  inline constexpr operator retType_5_23 () const noexcept
  {
    return __invoke;
  };
  
  private: 
  static inline /*constexpr */ void __invoke()
  {
    __lambda_5_23{}.operator()();
  }
  
  
};

__lambda_5_23 MyFunctor = __lambda_5_23{};
MyFunctor.operator()();
```
在这里可以很清晰的看到，编译展开后的 lambda 函数，就是通过仿函数实现的，编译创建了一个名为 __lambda_5_23 的类，然后用此类创建一个仿函数 MyFunctor，所以，实际上 lambda 可以理解为一个语法糖。

那么捕获又是怎么被实现的呢，我们来看下面这样的代码：
```cpp
int Var1;
int Var2;
auto MyFuctor1 = [&]() -> void { Var1 = 1; Var2 = 1; printf("Hello World!"); };
auto MyFuctor2 = [=]() -> void { printf("%d %d", Var1, Var2); };
MyFuctor1();
MyFuctor2();
```

这段代码编译器处理过后，我们只关注其生成的 lambda 类的代码，如下所示：
```cpp
// 引用捕获
class __lambda_7_18
{
  public: 
  inline /*constexpr */ void operator()() const
  {
    Var1 = 1;
    Var2 = 1;
    printf("Hello World!");
  }
  
  private: 
  int & Var1;
  int & Var2;
  
  public:
  __lambda_7_18(int & _Var1, int & _Var2)
  : Var1{_Var1}
  , Var2{_Var2}
  {}
  
};
// 按值捕获
class __lambda_8_18
{
  public: 
  inline /*constexpr */ void operator()() const
  {
    printf("%d %d", Var1, Var2);
  }
  
  private: 
  int Var1;
  int Var2;
  
  public:
  __lambda_8_18(int & _Var1, int & _Var2)
  : Var1{_Var1}
  , Var2{_Var2}
  {}
  
};
```
不难发现，引用捕获时，编译器便会创建私有的对应对象的引用，而按值捕获则会创建对应的变量。

值得注意的是，如果是指针，编译器只会执行浅拷贝，即直接对指针赋值，而不会进行深拷贝。

## 偏函数（Partial Function Application）
偏函数（Partial Function Application），国内于 C++ 的偏函数资料非常的少（几乎等于没有），这个名字的来源自 [https://www.modernescpp.com/index.php/partial-function-application](https://www.modernescpp.com/index.php/partial-function-application)，国内看到一篇文章翻译为了偏函数，觉得略有道理，故此处采用偏函数的译名。

偏函数，其实是利用 bind 将函数形参提前填入默认值，这和函数形参默认值是有所不同的，因为偏函数可以随意确定任意形参的默认值，就像这样：
```cpp
#include <stdio.h>
#include <functional>

void print(int a, int b, int c)
{
	printf("%d %d %d\n", a, b, c);
}

int main()
{
	using namespace std::placeholders;

	std::function<void(int, int)> print1 = std::bind(print, 10, _1, _2);
	std::function<void(int, int)> print2 = std::bind(print, _1, 10, _2);
	std::function<void(int, int)> print3 = std::bind(print, _1, _2, 10);

	print1(70, 12);
	print2(70, 12);
	print3(70, 12);

	return 0;
}
```
如果你在支持 C11 特性的编译器上编译，这段代码最终的运行结果会是：
```
10 70 12
70 10 12
70 12 10
```
所以，我们其实只需要一个原型函数，就可以利用 std::bind 来特化出其他的偏函数，非常方便。

而其中 std::bind 形参中的 _1、_2 其实都叫做“占位符”，这代表了不确定的参数（也就是最后产生的函数需要用户自行填写的形参）。